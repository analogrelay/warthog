extern crate serde_json;

use serde_json::{Map, Value};
use std::{env, fs, io::Write, path::Path, process};

fn main() {
    // Arg 0 is the executable name
    let arg0 = env::args().nth(0).unwrap();
    let args: Vec<_> = env::args().skip(1).collect();

    if args.len() > 0 {
        let file = &args[0];
        run(Path::new(file));
    } else {
        eprintln!("Usage: {} <wast json file>", arg0);
        process::exit(1);
    }
}

fn run(file: &Path) {
    let _dir = file.parent().unwrap().clone();
    let target = file.with_file_name("mod.rs");
    let name = file
        .file_stem()
        .and_then(|x| x.to_str())
        .map(|x| x.to_string())
        .expect("expected a file stem");

    // Load the json file
    let v: Value = {
        let f = fs::File::open(file).expect("failed to open source json file");
        serde_json::from_reader(f).expect("failed to parse json file")
    };

    // Get the commands
    let commands = match v.get("commands") {
        Some(ref mut c) => c.as_array().expect("expected 'commands' to be an array"),
        None => panic!("invalid JSON! could not find 'commands' property"),
    };

    // Open the target file
    let mut target = fs::File::create(target).expect("failed to open target file");

    // Write the header
    writeln!(
        target,
        "// This file was generated by the 'specgen' tool. Do not modify it."
    ).unwrap();
    writeln!(target, "use crate::TestContext;").unwrap();
    writeln!(target, "").unwrap();

    // Write the test definition
    writeln!(target, "#[test]").unwrap();
    writeln!(target, "pub fn {}() {{", name).unwrap();
    writeln!(target, "    let mut c = TestContext::new();").unwrap();

    // Visit commands
    for command in commands {
        let vals = command
            .as_object()
            .expect("expected command to be a JSON object");
        write_command(&mut target, vals);
    }

    // Write the trailer
    writeln!(target, "}}").unwrap();
}

fn write_command<W: Write>(target: &mut W, command: &Map<String, Value>) {
    let typ = command.get("type").and_then(|x| x.as_str()).unwrap();

    writeln!(target, "    {{").unwrap();
    match typ {
        "module" => write_module(target, command),
        "assert_return" => write_assert_return(target, command),
        "assert_trap" => write_assert_trap(target, command),
        "assert_return_canonical_nan" | "assert_return_arithmetic_nan" => {
            write_assert_nan(target, command)
        }
        x => writeln!(
            target,
            "        unimplemented!({});",
            to_literal(format!("{} command", x))
        ).unwrap(),
    }
    writeln!(target, "    }};").unwrap();
}

fn write_source_location<W: Write>(target: &mut W, command: &Map<String, Value>) {
    let line = command.get("line").and_then(|x| x.as_i64()).unwrap();
    writeln!(target, "        c.set_line({});", line).unwrap();
}

fn write_module<W: Write>(target: &mut W, command: &Map<String, Value>) {
    write_source_location(target, command);

    let module_file = command.get("filename").and_then(|x| x.as_str()).unwrap();
    let module_name = Path::new(module_file)
        .file_stem()
        .and_then(|x| x.to_str())
        .unwrap();
    writeln!(
        target,
        "        c.load_module({}, include_bytes!({}));",
        to_literal(module_name),
        to_literal(module_file)
    ).unwrap();
}

fn write_assert_nan<W: Write>(target: &mut W, command: &Map<String, Value>) {
    write_source_location(target, command);

    let action = command.get("action").and_then(|x| x.as_object()).unwrap();
    write_action(target, action);

    writeln!(target, "        c.assert_nan(actual);").unwrap();
}

fn write_assert_trap<W: Write>(target: &mut W, command: &Map<String, Value>) {
    write_source_location(target, command);

    let action = command.get("action").and_then(|x| x.as_object()).unwrap();
    write_action(target, action);

    let text = command.get("text").and_then(|x| x.as_str()).unwrap();
    writeln!(
        target,
        "        c.assert_trap({}, actual);",
        to_literal(text)
    ).unwrap();
}

fn write_assert_return<W: Write>(target: &mut W, command: &Map<String, Value>) {
    write_source_location(target, command);

    let action = command.get("action").and_then(|x| x.as_object()).unwrap();
    write_action(target, action);

    let expected = command.get("expected").and_then(|x| x.as_array()).unwrap();
    write_expectation(target, expected);

    writeln!(target, "        c.assert_return(expected, actual);").unwrap();
}

fn write_action<W: Write>(target: &mut W, command: &Map<String, Value>) {
    let typ = command.get("type").and_then(|x| x.as_str()).unwrap();
    match typ {
        "invoke" => write_invoke(target, command),
        x => writeln!(
            target,
            "        unimplemented!({})",
            to_literal(format!("{} action", x))
        ).unwrap(),
    }
}

fn write_invoke<W: Write>(target: &mut W, command: &Map<String, Value>) {
    let field = command.get("field").and_then(|x| x.as_str()).unwrap();
    let args = command.get("args").and_then(|x| x.as_array()).unwrap();
    write!(
        target,
        "        let actual = c.invoke(None, {}, vals!(",
        to_literal(field)
    ).unwrap();
    for (i, arg) in args.iter().enumerate() {
        let arg = arg.as_object().unwrap();
        if i > 0 {
            write!(target, ", ").unwrap();
        }
        write_val(target, arg);
    }
    writeln!(target, "));").unwrap();
}

fn write_expectation<W: Write>(target: &mut W, expected: &Vec<Value>) {
    write!(target, "        let expected = vals!(").unwrap();
    for exp in expected {
        let exp = exp.as_object().unwrap();
        write_val(target, exp)
    }
    writeln!(target, ");").unwrap();
}

fn write_val<W: Write>(target: &mut W, val: &Map<String, Value>) {
    let typ = val.get("type").and_then(|x| x.as_str()).unwrap();
    let value = val.get("value").and_then(|x| x.as_str()).unwrap();
    match typ {
        "i32" => write!(target, "{}_u32", value).unwrap(),
        "i64" => write!(target, "{}_u64", value).unwrap(),
        "f32" => write!(target, "f32::from_bits({}_u32)", value).unwrap(),
        "f64" => write!(target, "f64::from_bits({}_u64)", value).unwrap(),
        x => unimplemented!("values of type: {}", x),
    };
}

fn to_literal<S: AsRef<str>>(val: S) -> String {
    let val = jstring_to_rstring(val.as_ref());
    let mut s = String::new();
    s.push('\"');
    for c in val.chars() {
        for d in c.escape_default() {
            s.push(d);
        }
    }
    s.push('\"');
    s
}

// Borrowed from https://github.com/pepyakin/wabt-rs/blob/16603d07aedbf071659b0f2d60bc4bd9e9066aed/src/script/mod.rs#L255
// Under Apache 2 license: https://github.com/pepyakin/wabt-rs/blob/16603d07aedbf071659b0f2d60bc4bd9e9066aed/LICENSE

// Convert json string to correct rust UTF8 string.
// The reason is that, for example, rust character "\u{FEEF}" (3-byte UTF8 BOM) is represented as "\u00ef\u00bb\u00bf" in spec json.
// It is incorrect. Correct BOM representation in json is "\uFEFF" => we need to do a double utf8-parse here.
// This conversion is incorrect in general case (casting char to u8)!!!
fn jstring_to_rstring(jstring: &str) -> String {
    let jstring_chars: Vec<u8> = jstring.chars().map(|c| c as u8).collect();
    String::from_utf8(jstring_chars).unwrap()
}
