extern crate serde_json;

use serde_json::{Map, Value};
use std::{env, fs, io::Write, path::Path, process};

fn main() {
    // Arg 0 is the executable name
    let arg0 = env::args().nth(0).unwrap();
    let args: Vec<_> = env::args().skip(1).collect();

    if args.len() > 0 {
        let file = &args[0];
        run(Path::new(file));
    } else {
        eprintln!("Usage: {} <wast json file>", arg0);
        process::exit(1);
    }
}

fn run(file: &Path) {
    let _dir = file.parent().unwrap().clone();
    let target = file.with_extension("rs");
    let name = file
        .file_stem()
        .and_then(|x| x.to_str())
        .map(|x| x.to_string())
        .expect("expected a file stem");

    // Load the json file
    let v: Value = {
        let f = fs::File::open(file).expect("failed to open source json file");
        serde_json::from_reader(f).expect("failed to parse json file")
    };

    // Get the commands
    let commands = match v.get("commands") {
        Some(ref mut c) => c.as_array().expect("expected 'commands' to be an array"),
        None => panic!("invalid JSON! could not find 'commands' property"),
    };

    // Open the target file
    let mut target = fs::File::create(target).expect("failed to open target file");

    // Write the header
    writeln!(
        target,
        "// This file was generated by the 'specgen' tool. Do not modify it."
    )
    .unwrap();
    writeln!(target, "extern crate warthog;").unwrap();
    writeln!(target, "").unwrap();

    // Write the test definition
    writeln!(target, "#[test]").unwrap();
    writeln!(target, "pub fn {}() {{", name).unwrap();

    // Visit commands
    for command in commands {
        let vals = command
            .as_object()
            .expect("expected command to be a JSON object");
        write_command(&mut target, vals);
    }

    // Write the trailer
    writeln!(target, "}}").unwrap();
}

fn write_command<W: Write>(target: &mut W, command: &Map<String, Value>) {
    let typ = command.get("type").and_then(|x| x.as_str()).unwrap();

    writeln!(target, "    {{").unwrap();
    match typ {
        "module" => write_module(target, command),
        "assert_return" => write_assert_return(target, command),
        x => writeln!(target, "    unimplemented!(\"{}\" commands);", x).unwrap(),
    }
    writeln!(target, "    }}").unwrap();
}

fn write_source_location<W: Write>(target: &mut W, command: &Map<String, Value>) {
    let line = command.get("line").and_then(|x| x.as_i64()).unwrap();
    writeln!(target, "        source_location!({});", line).unwrap();
}

fn write_module<W: Write>(target: &mut W, command: &Map<String, Value>) {
    write_source_location(target, command);

    let module_file = command.get("filename").and_then(|x| x.as_str()).unwrap();
    writeln!(target, "        load_module!(\"{}\");", module_file).unwrap();
}

fn write_assert_return<W: Write>(target: &mut W, command: &Map<String, Value>) {
    write_source_location(target, command);

    let action = command.get("action").and_then(|x| x.as_object()).unwrap();
    write_action(target, action);

    let expected = command.get("expected").and_then(|x| x.as_array()).unwrap();
    write_expectation(target, expected);

    writeln!(target, "        assert_vals!(expected, actual);").unwrap();
}

fn write_action<W: Write>(target: &mut W, command: &Map<String, Value>) {
    let typ = command.get("type").and_then(|x| x.as_str()).unwrap();
    writeln!(
        target,
        "        let actual = {{ unimplemented!(\"{} actions\") }};",
        typ
    )
    .unwrap();
}

fn write_expectation<W: Write>(target: &mut W, expected: &Vec<Value>) {
    write!(target, "        let expected = vec![").unwrap();
    for exp in expected {
        let exp = exp.as_object().unwrap();
        write_val(target, exp)
    }
    writeln!(target, "];").unwrap();
}

fn write_val<W: Write>(target: &mut W, val: &Map<String, Value>) {
    let typ = val.get("type").and_then(|x| x.as_str()).unwrap();
    let value = val.get("value").and_then(|x| x.as_str()).unwrap();
    match typ {
        "i32" => write!(target, "{}_i32", value).unwrap(),
        x => unimplemented!("values of type: {}", x),
    };
}
